# 운영체제(Operating System)
=>`가상화` ,`병행성` ,`영속성`
한정된 메모리나 시스템 자원을 효율적으로 분배

```
운영체제와 컴퓨터
 - 운영체제의 구조
  * 시스템콜
 - 컴퓨터의 요소
  * CPU
  * DMA 컨트롤러
  * 메모리
  * 타이머
  * 디바이스 컨트롤러
- 메모리
```
## 운영체제와 컴퓨터
운영체제의 역할
- CPU 스케줄링과 프로세스 관리 : CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리
- 메모리 관리 : 한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리
- 디스크 파일 관리 : 디스크 파일을 어떠한 방법으로 보관할 지 관리
- I/O 디바이스 관리 : I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리

### 운영체제의 구조
![[Pasted image 20220530002352.png]]
유저 프로그램(응용프로그램)
GUI
시스템콜
커널
드라이버 : 하드웨어를 제어하기 위한 소프트웨어
하드웨어
GUI, 시스템콜, 커널, 드라이버의 부분이 운영체제를 지칭한다.
GUI가 없고 CUI(command user interface)만 있는 리눅스도 있다. 하지만 모든 리눅스가 CUI로만 이루어진 것은 아님.

**시스템콜**
: 운영체제가 커널에 접근하기 위한 인터페이스. 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용

![[Pasted image 20220530002737.png]]
시스템 콜의 목적 : 컴퓨터 자원에 대한 직접 접근을 차단하고 프로그램을 다른 프로그램으로부터 보호할 수 있음. 시스템콜은 커널을 작성한 언어에 의해 동작함.
> I/O 요청 : 입출력 함수, 데이터베이스, 네트워크, 파일 접근
> 드라이버 : 하드웨어를 제어하기 위한 소프트웨어

```
시스템 콜의 종류
**2.4.1 프로세스 제어(Process Control)**
-   끝내기(end), 중지(abort)
-   적재(load), 실행(execute)
-   프로세스 생성(create process)
-   프로세스 속성 획득과 설정(get process attribute and set process attribute)
-   시간 대기(wait time)
-   사건 대기(wait event)
-   사건을 알림(signal event)
-   메모리 할당 및 해제 : malloc, free

**2.4.2 파일 조작(File Manipulation)**
-   파일 생성(create file), 파일 삭제(delete file)
-   열기(open), 닫기(close)
-   읽기(read), 쓰기(write), 위치 변경(reposition)
-   파일 속성 획득 및 설정(get file attribute and set file attribute)

**2.4.3 장치 관리(Devide Management)**
-   장치를 요구(request devices), 장치를 방출release device)
-   읽기, 쓰기, 위치 변경
-   장치 속성 획득, 장치 속성 설정
-   장치의 논리적 부착(attach) 또는 분리(detach)

**2.4.4 정보 유지(Information Maintenance)**
-   시간과 날짜의 설정과 획득(time)
-   시스템 데이터의 설정과 획득(date)
-   프로세스 파일, 장치 속성의 획득 및 설정

**2.4.5 통신(Communication)**
-   통신 연결의 생성, 제거
-   메시지의 송신, 수신
-   상태 정보 전달
-   원격 장치의 부착 및 분리



부연설명) 시스템콜은 하나의 추상화 계층.(137p)
```
시스템 콜의 작동 방식
- modebit
시스템콜이 작동될 때 modebit을 참고해서 유저모드와 커널 모드를 구분한다. modebit은 1또는 0의 값을 가지는 플래그 변수이다.
예를 들면, I/O 디바이스는 운영체제를 통해서만 작동해야 한다.
커널 모드를 거쳐 운영체제를 통해 작동한다고 해도 100% 외부 공격을 막을 수는 없지만 운영체제를 통해 작동하게 해야 막기가 쉽다. (캡슐화) 이를 위한 장치가 modebit이다.
modebit의 0은 커널모드, 1은 유저 모드라고 설정된다. 유저 모드일 경우에는 시스템콜을 못하게 막아서 한정된 일만 가능하게 한다.
![[Pasted image 20220530003214.png]]

유저 프로세스가 실행되서 시스템 콜을 호출하고(trap()* ) modebit이 0으로 바뀌고 자원을 이용한 로직을 처리한 후 시스템콜을 다시 호출하여 modebit을 1로 리턴하고 유저 모드로 바뀌어 유저프로세스의 시스템 콜로 돌아간다. 
> WHY?
> -> 운영체제의 설계 원칙중 고립(isolation)원칙 : 한 프로그램의 악의적인 또는 의도치 않은 행위가 다른 프로그램에게 피해를 주지 않는다는 것을 보장해야 한다. 따라서 프로세스를 다른 프로세스로부터 고립시키는 것은 보호의 핵심이고 운영체제가 해야 하는 일 중 많은 부분의 근간이 된다.
> Operating system, three easy pieces 13p

> 시스템 콜과 프로시저 호출의 결정적 차이는 다음과 같다. 시스템 콜은 제어를 운영체제에게 넘길 때 하드웨어 특권 수준(hardware privilege level)을 상향 조정한다는 것이다. 사용자모드에서는 응용프로그램이 할 수 있는 일을 하드웨어적으로 제한한다.
> 예를 들어 사용자 모드에서 실행중인 응용 프로그램은 디스크 입출력, 물리 메모리 페이지 접근 또는 네트워크 패킷 송신 등의 작업을 할 수 없다.
> 
> 시스템 콜은 보통 trap이라고 불리는 특별한 하드웨어 명령어를 이용하여 호출된다. 시스템 콜 시작 시, 하드에어는 미리 지정된 트랩 핸들러(trap handler)함수에게 제어권을 넘기고 특권 수준을 커널 모드(kernel mode)로 격상시킨다. 트랩 핸들러 함수는 운영체제가 미리 구현해놓는다. 운영체제가 서비스를 완료하면 return-from-trap 특수 명령어를 사용하여 제어권을 다시 사용자에게 넘긴다. 이 명령어는 응용프로그램이 출발했던 지점으로 제어권을 넘기는 동시에 다시 사용자 모드로 전환한다. 
> Operating system, three easy pieces 15p

cf) 시스템 콜 (~나중의 나를 위해 보아라~)
![[Pasted image 20220530141436.png]]
> User API Program을 실행하게 되면 User API는 하나의 Process가 됩니다. Run-time 동안 library 함수인 printf(3) 호출하게 되고 이는 내부에 write(2)라는 system call 함수를 재차 호출합니다. 이렇게 호출된 write(2) library 함수(aka system call 함수)를 wrapper 함수라고 하며, 이상의 과정을 system call wrapper routine이라고 합니다.
> 이 library 함수는 CPU내에 있는 범용 register 중의 하나인 eax register에 write(2) 함수에 할당되어 있는 고유한 번호인 4를 넣습니다. 다음으로 0x80을 인자로 트랩(trap)을 걸게 됩니다. 여기서 int는 C의 자료형이 아니라 Intel CPU에서 트랩을 거는 명령입니다. CPU-mode-bit(chmodk : 0 --> 1)가 변경되면서 트랩이 걸리면 CPU의 수행모드가 사용자수준(user-space)에서 커널수준(kernel-space)로 넘어가게 됩니다. 그리고 커널은 현재 수행중이던 태스크 문맥(context)를 저장하게 됩니다.


![[Pasted image 20220530141526.png]]
> 커널은 트랩 번호인 0x80(Intel CPU에서...)을 IDT(Interrupt Descriptor Table)에 검색하여 이에 해당하는 system_call()을 엔트리(ENTRY)에서 호출합니다. system_call()은 [~/arch/x86/kernel/entry_32.S](https://docs.wixstatic.com/ugd/10545b_e35e16ce944546ec9aace7597090f170.pdf) 또는 /entry_64.S(ubuntu 기준)에 구현 되어 있습니다.
> 이 함수는 eax(=4) 값을 index로 sys_call_table을 탐색합니다. 이 table은 [~/arch/x86/kernel/syscall_32.c](https://docs.wixstatic.com/ugd/10545b_0658b73d3588464785d552b32e70a0f5.pdf) 또는 /syscall_64.c에 구현되어 있으며, 각 시스템 콜에 할당되어 있는 고유한 번호는 [~/arch/x86/syscalls/syscall_32.tbl](https://docs.wixstatic.com/ugd/10545b_2c2e0673bfbb4985a21d12abdaae7db7.pdf) 혹은 /syscall_64.tbl에서 확인할 수 있습니다.('~'는 linux source code가 있는 디렉토리 입니다. 저의 경우는 ubuntu를 사용하는데, '~'는 /usr/src/linux-3.4.6 입니다.)
> 현재 eax register에 들어있는 4값으로 sys_write의 포인터 값을 받아 sys_write()함수를 호출하게 됩니다. sys_write()는 [~/fs](https://docs.wixstatic.com/ugd/10545b_44324e8d9878499ea03aea2e5f0ff2fe.pdf)에 구현되어 있으며, sys_fork()는 [~/arch/x86/kernel](https://docs.wixstatic.com/ugd/10545b_f55b7b18d6cd45959f9b157f124dd4c3.pdf)에 구현되어 있습니다.(sys_fork() 함수 내의 do_fork() 함수는 [~/kernel](https://docs.wixstatic.com/ugd/10545b_f6b7f4484fe840ddb780bdfe1e367c76.pdf)에 있습니다.)
> 참고로 linux에서 시스템 호출을 서비스 해주는 함수는 전통적으로 sys_라는 접두어가 붙습니다. 사실 한 번쯤은 자기만의 시스템 콜을 만들어 보는 것이 좋은데, kernel compile을 해야된다는 점과 그렇게 만든 시스템 콜은 자기 시스템에서만 가능하기 때문에 여기서는 과감히 생략하도록 하겠습니다


### 컴퓨터의 요소
CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러
![[Pasted image 20220530003814.png]]
(적절한 짤을 못찾음)
**CPU**
: 인터럽트(interrupt)에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행하는 장치
산술논리연산장치, 제어장치, 레지스터로 구성.
> 책의 비유
> 관리자 역할 : 운영체제의 커널
> 커널이 프로그램을 메모리에 올려 프로세스로 만들면,
> 일꾼 역할 : CPU가 이를 처리

**제어장치**
프로세스 조작을 지시하는 CPU의 한 부분
입출력 장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정

**레지스터**
CPU안에 있는 매우 빠른 임시기억장치. CPU는 자체적으로 데이터를 저장할 방법이 없기 때문에 레지스터를 거쳐 데이터를 전달한다.

> cf) 메모리 간 속도
레지스터 > RAM > L1캐시, L2캐시 > HDD, SSD

**산술논리연산장치**
산술연산과 배타적 논리합, 논리곱같은 논리 연산을 계산하는 디지털 회로

 - CPU의 연산 처리
![[Pasted image 20220530004716.png]]
Control Unit(제어장치)가 메모리에 계산할 값을 로드한다. 레지스터에도 로드한다.
Control Unit(제어장치)에 있는 값을 계산하라고 산술논리연산장치에 명령한다.
제어장치가 계산된 값을 다시 레지스터에서 메모리로 계산한 값을 저장한다.

나의 의문 => 데이터를 메모리와 레지스터 둘다 로드하는 이유가 뭐임?
<레지스터 <-> 메모리의 차이>
> 레지스터와 메모리의 주된 차이점은 레지스터가 CPU가 현재 처리 중인 데이터를 보유하는 반면 메모리는 처리에 필요한 데이터를 보유한다는 것이다. 레지스터 범위는 32비트 레지스터에서 64비트 레지스터까지이며 메모리 용량은 일부 GB에서 일부 TB까지이다.
> https://techdifferences.com/difference-between-register-and-memory.html


**인터럽트**
어떤 신호(I/O 디바이스에 의한 인터럽트, 산술 연산에서의 인터럽트, 프로세스 오류)가 들어왔을 때 CPU를 잠깐 정지시키는 것

- 하드웨어 인터럽트
: I/O 디바이스에서 발생하는 인터럽트
순차적인 인터럽트 실행을 중지하고 운영체제에 시스템 콜을 요청해서 디바이스에 있는 작은 로컬 버퍼에 접근하여 일을 수행

- 소프트웨어 인터럽트(트랩)
: 프로세스 오류 등으로 프로세스가 시스템 콜을 호출할 때 발동

**DMA 컨트롤러**
I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치. CPU에만 너무 많은 인터럽트 요청이 들어오기 떄문에 CPU의 부하를 막아주며 하나의 작업을 CPU와 DMA 컨트롤러가 동시에 하는 것을 방지한다.

**메모리**
: 데이터나 상태, 명령어 등을 기록하는 장치. 보통 RAM(random access memory)을 메모리라고도 한다. 메모리가 크면 클수록 많은 일을 동시에 할 수 있다.
(공간분할)

**타이머**
몇 초 안에는 작업이 끝나야 한다는 것을 정하고 특정 프로그램에 시간 제한을 다는 역할을 한다.

**디바이스 컨트롤러**
컴퓨터와 연결되어 있는 I/O 디바이스들의 작은 CPU

## 메모리
**메모리 계층**
레지스터, 캐시, 메모리, 저장장치로 구성
![[Pasted image 20220530180959.png]]
> 메모리 계층구조(memory hierarcy)가 존재하는 이유
> -   Memory 분배가 쉽고 경제적이다.
> - 외부에서 파괴되지 않는다.
> -  데이터가 어디로든 전달될 수 있다.
> - pre-paging을 허용하고 paging을 요구한다.
> - Swapping시에 훨씬 더 유리하다

![[Pasted image 20220530182308.png]]
	메모리 계층에서 액세스 시간은 데이터 가용성과 읽기 또는 쓰기 요청을 보낸 후 데이터를 쓸 수 있을때까지의 시간을 말한다. 메모리 계층의 맨 위에서 아래로 이동할수록 액세스 시간이 증가한다.
	이 메모리 구성에서 CPU는 항상 첫 번째 메모리 레벨의 데이터에 액세스합니다. 레벨 1에 누락이 있을 때마다 데이터는 상위 레벨의 메모리에서 하위 레벨의 메모리로 전송됩니다. 데이터 전송 후 CPU는 하위 레벨에서 데이터에 액세스합니다.


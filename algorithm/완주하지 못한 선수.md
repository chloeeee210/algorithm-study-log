# 내 풀이
```javascript
function solution(participant, completion) {

	const runnerMap = new Map();
	    for (const runner of participant) {
	        runnerMap.set(runner, (runnerMap.get(runner)|| 0)+1 )
	    }

	const completedMap = new Map();
	    for(const completed of completion) {
	        completedMap.set(completed, (completedMap.get(completed)||0) +1)
	    }
    
	const runnerArr = [...runnerMap.entries()]

return runnerArr.find((entry)=> entry[1] !== completedMap.get(entry[0]))[0]
}

```

## 삽질과정 (하루 종일 고민한 거 억울해서 씀)
처음에는 맵카운터(아래 코드)를 참가자 리스트와 완주한 인간 리스트를 합쳐서 만들었었다. 왜냐면 중복을 걸러야 한다는 걸 제대로 생각을 못했기 때문에...
```javascript
// Mapcounter
	const completedMap = new Map();
	    for(const completed of completion) {
	        completedMap.set(completed, (completedMap.get(completed)||0) +1)
	    }
```

```javascript
const runnerList = new Map();
	for (const runner of participant){
		for (const completedRunner of completion){
			if(runner == completedRunner){
				runnerList.set(runner, completedRunner)
			}		
		}
	}
	console.log(runnerList)	
```

> **input**
> ["leo", "kiki", "eden"], ["eden", "kiki"]
> **expected**
> "leo"
>**console**
>Map { 'kiki' => 'kiki', 'eden' => 'eden' }

이렇게 하면 **중복을 못거른다**
왜냐하면 참가한 인간들 리스트와 완주한 인간 리스트가 개별적으로 존재해야 중복값이 있는 지 비교할 수 있기 때문. 카운터를 애초에 잘못 구현한게 문제 
각각의 카운터를 구현한 다음 그 값을 비교해야...ㄱ-

```javascript
	const runnerMap = new Map();
	    for (const runner of participant) {
	        runnerMap.set(runner, (runnerMap.get(runner) || 0)+1 )
	    }

	const completedMap = new Map();
	    for(const completed of completion) {
	        completedMap.set(completed, (completedMap.get(completed) || 0) +1)
	    }

	console.log(runnerMap)
	console.log(completedMap)

```
카운터 두 개에 뭐가 들어있는 지 확인

> Map { 'leo' => 1, 'kiki' => 1, 'eden' => 1 } //runnerMap
> Map { 'eden' => 1, 'kiki' => 1 } //completedMap

